/*
 * TER Software - More than an implementation of CCSDS Recommendation for Image Data Compression
 * Copyright (C) 2007  Group on Interactive Coding of Images (GICI)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Group on Interactive Coding of Images (GICI)
 * Department of Information and Communication Engineering
 * Autonomous University of Barcelona
 * 08193 - Bellaterra - Cerdanyola del Valles (Barcelona)
 * Spain
 *
 * http://gici.uab.es
 * http://sourceforge.net/projects/ter
 * gici-info@deic.uab.es
 */
package TER.TERcoder.WriteFile;

import GiciStream.*;
import GiciException.*;

/**
 * This class interleaves the bitstreams generated by the Bit Plane Encoder in order to produce an encoded segment.
 *  
 * Usage example:<br>
 * &nbsp; construct<br>
 * &nbsp; setParameters<br>
 * &nbsp; run<br>
 *
 * @author Group on Interactive Coding of Images (GICI)
 * @version 1.2
 */
public class RecommendedInterleaving{
	
	/**
	 * This array is employed to store the encoded segment according to the given parameters. 
	 */
	BitStream codedSegment = null;
	
	/**
	 * This array stores for each gaggle the initial coding of DC quantized components
	 */
	BitStream initialCodedDC[] = null;
	
	/**
	 * This array stores for each gaggle the encoded bit depth of AC components of each block
	 */
	BitStream codedBitDepthACBlock[] = null;
	
	/**
	 * This array stores for each gaggle and bitplane the refinement of DC components
	 */
	BitStream refinementDC[][] = null;
	
	/**
	 * 	This array stores for each gaggle, bitplane and resolution level the encoded significance of AC components of the segment
	 *  sortingAC[gaggle][bitPlane][resolutionLevel]
	 */
	BitStream sortingAC[][][] = null;
	
	/**
	 * This array stores for each gaggle, bitplane, block and resolution level the refinement of AC components
	 *	refinementAC[gaggle][bitPlane][block][resolutionLevel]
	 */
	BitStream refinementAC[][][][] = null;
	
	/**
	 * Definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#bitDepthAC}
	 */
	int bitDepthAC;
	
	/**
	 * Definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#resolutionLevels}
	 */
	int resolutionLevels;
	
	/**
	 * To know if parameters are set.
	 * <p>
	 * True indicates that they are set otherwise false.
	 */
	boolean parametersSet = false;
		
	/**
	 * Indicates the maximum number of bits that can be used to create the segment 
	 */
	long segBitLimit;
	
	/**
	 * Definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#DCStop}
	 */
	int DCStop;
	
	/**
	 * Definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#bitPlaneStop}
	 */
	int bitPlaneStop;
	
	/**
	 * Definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#stageStop}
	 */
	int stageStop;
	
	/**
	 * Indicates the truncation points that must be used to create the encoded segment
	 * <p>
	 * Valid values are:<br>
	 *   <ul>
	 *     <li> 0 - none 
	 *     <li> 1 - end of bitplane (bitPlaneStop)
	 *     <li> 2 - end of resolution level (stageStop)
	 *     <li> 3 - end of gaggle
	 *     </ul> 
	 */
	int truncationPoints;
	
	/**
	 * Indicates the number of bits inserted into the encoded segment
	 */
	long bitsCounter;
	
	/**
	 * Definition in {@link RecommendedOrder#pixelBitDepth}
	 */
	int pixelBitDepth;
	
	/**
	 * Definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#blocksPerSegment}
	 */
	int blocksPerSegment;

	int codingPasses;

	int gaggleSizeAC, gaggleSizeDC;
	/**
	 * Constructor of InterleaveSegment
	 */
	public RecommendedInterleaving(){

	}
	
	/**
	 * Set the parameters required to interleave the segment
	 * 
	 * @param initialCodedDC defintion in {@link #initialCodedDC}
	 * @param codedBitDepthACBlock defintion in {@link #codedBitDepthACBlock}
	 * @param refinementDC defintion in {@link #refinementDC}
	 * @param sortingAC defintion in {@link #sortingAC}
	 * @param refinementAC defintion in {@link #refinementAC}
	 * @param bitDepthAC defintion in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#bitDepthAC}
	 * @param resolutionLevels defintion in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#resolutionLevels}
	 * @param segByteLimit defintion in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#segByteLimit}
	 * @param DCStop defintion in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#DCStop}
	 * @param bitPlaneStop defintion in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#bitPlaneStop}
	 * @param stageStop defintion in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#stageStop}
	 * @param truncationPoints definition in {@link #truncationPoints}
	 * @param headerLength indicates the size in bytes of the header of the segment
	 * @param pixelBitDepth definition in {@link RecommendedOrder#pixelBitDepth}
	 * @param blocksPerSegment definition in {@link TER.TERcoder.SegmentCoder.SegmentCode2D#blocksPerSegment}
	 */
	public void setParameters(BitStream initialCodedDC[], BitStream codedBitDepthACBlock[], BitStream refinementDC[][], 
			BitStream sortingAC[][][], BitStream refinementAC[][][][], int bitDepthAC, int resolutionLevels, 
			int segByteLimit, int DCStop, int bitPlaneStop, int stageStop, 
			int truncationPoints, int headerLength, int pixelBitDepth, int blocksPerSegment,
			int gaggleSizeDC, int gaggleSizeAC){
		
		this.initialCodedDC = initialCodedDC;
		this.codedBitDepthACBlock = codedBitDepthACBlock;
		this.refinementDC = refinementDC;
		this.sortingAC = sortingAC;
		this.refinementAC = refinementAC;
		this.bitDepthAC = bitDepthAC;
		this.resolutionLevels = resolutionLevels;

		this.segBitLimit = segByteLimit*8;
		this.DCStop = DCStop;
		this.bitPlaneStop = bitPlaneStop;
		this.stageStop = stageStop;

		this.truncationPoints = truncationPoints;
		this.pixelBitDepth = pixelBitDepth;
		this.blocksPerSegment = blocksPerSegment;
		
		this.gaggleSizeDC = gaggleSizeDC;
		this.gaggleSizeAC = gaggleSizeAC;
		
		bitsCounter = headerLength*8;
		codingPasses = 1; //segment header
		
		parametersSet = true;
	}
	
	
	/**
	 * Creates the encoded segment according to the progression given by the user
	 * 
	 * @return a BitStream containing the interleaved segment
	 * 
	 * @throws Exception when something goes wrong and the interleaving of the encoded segment must be stopped
	 */
	public BitStream run() throws Exception{
		//If parameters are not set run cannot be executed
		if(!parametersSet){
			throw new ParameterException("The segment cannot be interleaved if parameters are not set.");
		}
		
		int bufferAllocation = ((int) segBitLimit) + 128;
		int sideBlockSize = ( (int) 1<< resolutionLevels );
		int inputSegmentSize = (sideBlockSize*sideBlockSize)*pixelBitDepth*blocksPerSegment;
		if ( bufferAllocation > inputSegmentSize ){
			bufferAllocation = inputSegmentSize;
		}
		codedSegment = new BitStream(bufferAllocation);
		
		try{
		// Initial coding are inserted
		putQuantizedDC();
		
		// DCs are refined if needed 
		if(refinementDC!=null){
			for(int bitPlane=refinementDC[0].length -1 ; bitPlane>bitDepthAC-1; bitPlane--){
				putDCRefinement(bitPlane);
			}			
		}
		
		if (DCStop==0){
			// Bit depth of AC components
			if(codedBitDepthACBlock!=null){
				putCodedBitDepthACBlock();
			}
			
			for(int bitPlane=bitDepthAC-1 ; bitPlane>=bitPlaneStop; bitPlane--){
				if (truncationPoints==1){
					long requiredBits = 0;
					
					if(refinementDC!=null && bitPlane<refinementDC[0].length){
						for(int gaggle=0; gaggle<refinementDC.length ; gaggle++){
							requiredBits += refinementDC[gaggle][bitPlane].getNumBits();  
						}
					}
					
					if(sortingAC!=null){
						for(int rLevel=0; rLevel< resolutionLevels ; rLevel++){
							for(int gaggle=0; gaggle<sortingAC.length ; gaggle++){
								if (sortingAC[gaggle]!=null){				
									if (sortingAC[gaggle].length > bitPlane){
										if ( sortingAC[gaggle][bitPlane]!=null){
											if (sortingAC[gaggle][bitPlane][rLevel] != null) {
												requiredBits+=sortingAC[gaggle][bitPlane][rLevel].getNumBits();
											}
										}
									}
								}
							}
						}
					}
					
					if(refinementAC!=null && bitPlane!=bitDepthAC-1){
						for(int gaggle=0; gaggle<refinementAC.length; gaggle++){
							if (refinementAC[gaggle]!=null){
								if ( bitPlane < refinementAC[gaggle].length){
									if ( refinementAC[gaggle][bitPlane]!=null){
										for (int block=0; block < refinementAC[gaggle][bitPlane].length; block++){
											for (int rLevel=0; rLevel< resolutionLevels; rLevel++){
												if ( refinementAC[gaggle][bitPlane][block]!=null){
													if (refinementAC[gaggle][bitPlane][block][rLevel] != null) {		
														requiredBits+=refinementAC[gaggle][bitPlane][block][rLevel].getNumBits();
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					if (requiredBits+bitsCounter>segBitLimit){
						updateCodingPasses(0,true);
					}
					
				}
				// DC are refined if needed
				if(refinementDC!=null && bitPlane<refinementDC[0].length){
					putDCRefinement(bitPlane);
				}
				// Magnitude of AC components is set
				if(sortingAC!=null){
					putSortingAC(bitPlane);
				}
				// Refinement of AC components is added
				if(refinementAC!=null && bitPlane!=bitDepthAC-1){
					putACRefinement(bitPlane);
				}
			}
		}
		} catch (ParameterException e){
			//The maximum size has been achieved. According to the given parameters, there is not enough space to encode all the bitplanes. 
		}
		
		fillExtraBits();
		
		return this.codedSegment;
	}

	private void updateCodingPasses(int addedPasses,boolean stop) throws ParameterException{
		if (stop){
			throw new ParameterException();
		} else {
			codingPasses+=addedPasses;
		}
	}
	
	/**
	 * Initial DC coding is added 
	 * 
	 * @throws WarningException
	 */
	private void putQuantizedDC() throws WarningException, ParameterException{
		// fisrt we look if the number of bits required to encode up to a truncation point are available
		if (truncationPoints==1 || truncationPoints==2){// truncationPoints : bit plane or resolution level
			int requiredBits = 0;
			for(int gaggle=0; gaggle<initialCodedDC.length ; gaggle++){
				requiredBits += initialCodedDC[gaggle].getNumBits();  
			}
			if (requiredBits+bitsCounter>segBitLimit){
				updateCodingPasses(0,true);
				throw new WarningException("There are not enough bytes to send information of the image up to the first truncation point");
			}
		}
			
		for(int gaggle=0; gaggle<initialCodedDC.length ; gaggle++){
			if (initialCodedDC[gaggle] != null) {
				if (truncationPoints==3){// truncationPoints : gaggle
					if (initialCodedDC[gaggle].getNumBits()+bitsCounter>segBitLimit){
						updateCodingPasses(0,true);
						if (gaggle ==0){
							throw new WarningException("There are not enough bytes to send information of the image up to the first truncation point");
						}
					}
				}
				
				codedSegment.addBitStream(initialCodedDC[gaggle]);
				updateCodingPasses(gaggleSizeDC,false);
				bitsCounter += initialCodedDC[gaggle].getNumBits();
				if(bitsCounter>=segBitLimit){// no truncationPoints
					updateCodingPasses(0,true);
				}
				
			}
		}	
		
	}
	
	/**
	 * DC refinement is added for the given bitplane
	 * 
	 * @param bitPlane indicates the bit plane that is being added
	 */
	private void putDCRefinement(int bitPlane) throws ParameterException{
		// fisrt we look if the number of bits required to encode up to a truncation point are available
		if (truncationPoints==2){// truncationPoints : resolution level
			int requiredBits = 0;
			for(int gaggle=0; gaggle<refinementDC.length ; gaggle++){
				requiredBits += refinementDC[gaggle][bitPlane].getNumBits();  
			}
			if (requiredBits+bitsCounter>segBitLimit){
				updateCodingPasses(0,true);
			}
		}
		
		for(int gaggle=0; gaggle<refinementDC.length ; gaggle++){
			if (refinementDC[gaggle]!= null){
				if (refinementDC[gaggle][bitPlane] != null) {
					if (truncationPoints==3){// truncationPoints : gaggle
						if (refinementDC[gaggle][bitPlane].getNumBits()+bitsCounter>segBitLimit){
							updateCodingPasses(0,true);
						}
					}
					codedSegment.addBitStream(refinementDC[gaggle][bitPlane]);
					updateCodingPasses(gaggleSizeDC,false);
					bitsCounter += refinementDC[gaggle][bitPlane].getNumBits();
					if(bitsCounter>=segBitLimit){
						updateCodingPasses(0,true);
					}
					
				}
			}
		}		
		
	}
	
	/**
	 * Bit depth of AC components of each block is added
	 */
	private void putCodedBitDepthACBlock() throws ParameterException{

		for(int gaggle=0; gaggle<codedBitDepthACBlock.length ; gaggle++){
			if (codedBitDepthACBlock[gaggle] != null) {
				if (truncationPoints==3){// truncationPoints : gaggle
					if (codedBitDepthACBlock[gaggle].getNumBits()+bitsCounter>segBitLimit){
						updateCodingPasses(0,true);
					}
				}
				
				codedSegment.addBitStream(codedBitDepthACBlock[gaggle]);
				updateCodingPasses(gaggleSizeAC,false);
				bitsCounter += codedBitDepthACBlock[gaggle].getNumBits();;
				if(bitsCounter>=segBitLimit){
					updateCodingPasses(0,true);
				}
				
			}
		}
	}
	
	/**
	 * AC sorting is added for the given bitplane
	 * 
	 * @param bitPlane indicates the bit plane that is being added
	 */
	private void putSortingAC(int bitPlane) throws ParameterException{

		for(int rLevel=0; rLevel< this.resolutionLevels; rLevel++){
			if ( bitPlane<=bitPlaneStop && rLevel>=stageStop ){
				updateCodingPasses(0,true);
			}
			
			if (truncationPoints==2){//truncationPoints : resolution levels
				int requiredBits = 0;
				for(int gaggle=0; gaggle<sortingAC.length; gaggle++){
					if (sortingAC[gaggle]!=null){				
						if (sortingAC[gaggle].length > bitPlane){
							if ( sortingAC[gaggle][bitPlane]!=null){
								if (sortingAC[gaggle][bitPlane][rLevel] != null) {
									requiredBits+=sortingAC[gaggle][bitPlane][rLevel].getNumBits();
								}
							}
						}
					}
				}
				if (requiredBits+bitsCounter>segBitLimit){
					updateCodingPasses(0,true);
				}
			}
			
			
			for(int gaggle=0; gaggle<sortingAC.length; gaggle++){				
				if (sortingAC[gaggle]!=null){				
					if (sortingAC[gaggle].length > bitPlane){
						if ( sortingAC[gaggle][bitPlane]!=null){
							if (sortingAC[gaggle][bitPlane][rLevel] != null) {
								if (truncationPoints==3){//truncationPoints : gaggle
									if (sortingAC[gaggle][bitPlane][rLevel].getNumBits()+bitsCounter>segBitLimit){
										updateCodingPasses(0,true);
									}
								}
								codedSegment.addBitStream(sortingAC[gaggle][bitPlane][rLevel]);
								updateCodingPasses(gaggleSizeAC,false);
								bitsCounter+=sortingAC[gaggle][bitPlane][rLevel].getNumBits();
								if(bitsCounter>=segBitLimit){
									updateCodingPasses(0,true);
								}
								
							}
						}
					}
				}
				
			}
		}
	}
	
	/**
	 * AC refinement is added for the given bitplane
	 * 
	 * @param bitPlane indicates the bit plane that is being added
	 */
	private void putACRefinement(int bitPlane) throws ParameterException{
		
		if ( bitPlane<=bitPlaneStop && resolutionLevels>=stageStop ){	
			updateCodingPasses(0,true);	
		}
		if (refinementAC!=null && truncationPoints==2){// truncationPoints resolution level
			int requiredBits = 0;
			for(int gaggle=0; gaggle<refinementAC.length; gaggle++){
				if (refinementAC[gaggle]!=null){
					if ( bitPlane < refinementAC[gaggle].length){
						if ( refinementAC[gaggle][bitPlane]!=null){
							for (int block=0; block < refinementAC[gaggle][bitPlane].length; block++){
								for (int rLevel=0; rLevel< resolutionLevels; rLevel++){
									if ( refinementAC[gaggle][bitPlane][block]!=null){
										if (refinementAC[gaggle][bitPlane][block][rLevel] != null) {		
											requiredBits+=refinementAC[gaggle][bitPlane][block][rLevel].getNumBits();
										}
									}
								}
							}
						}
					}
				}
			}
			if (requiredBits+bitsCounter>segBitLimit){
				updateCodingPasses(0,true);
			}
		}
		if (refinementAC!=null){
			for(int gaggle=0; gaggle<refinementAC.length; gaggle++){
				if (truncationPoints==3){//truncationPoints : gaggle
					int requiredBits = 0;
					if (refinementAC[gaggle]!=null){
						if ( bitPlane < refinementAC[gaggle].length){
							if ( refinementAC[gaggle][bitPlane]!=null){
								for (int block=0; block < refinementAC[gaggle][bitPlane].length; block++){
									for (int rLevel=0; rLevel< resolutionLevels; rLevel++){
										if ( refinementAC[gaggle][bitPlane][block]!=null){
											if (refinementAC[gaggle][bitPlane][block][rLevel] != null) {		
												requiredBits+=refinementAC[gaggle][bitPlane][block][rLevel].getNumBits();
											}
										}
									}
								}
							}
						}
					}
				
					if (requiredBits+bitsCounter>segBitLimit){
						updateCodingPasses(0,true);
					}
				}
				
				if (refinementAC[gaggle]!=null){
					if ( bitPlane < refinementAC[gaggle].length){
						if ( refinementAC[gaggle][bitPlane]!=null){
							for (int block=0; block < refinementAC[gaggle][bitPlane].length; block++){
								for (int rLevel=0; rLevel< resolutionLevels; rLevel++){
									if ( refinementAC[gaggle][bitPlane][block]!=null){
										if (refinementAC[gaggle][bitPlane][block][rLevel] != null) {											
											codedSegment.addBitStream(refinementAC[gaggle][bitPlane][block][rLevel]);
											updateCodingPasses(1,false);
											bitsCounter+=refinementAC[gaggle][bitPlane][block][rLevel].getNumBits();
											if(bitsCounter>=segBitLimit){
												updateCodingPasses(0,true);
											}
										}
									}
								}
							}
						}
					}
				} 
			}
		}
		
	}
	
	/**
	 * Fill the empty bits (if any) of the last bit. 
	 */
	private void fillExtraBits(){
		int numberExtraBits = (int) codedSegment.getNumBits() % 8;
		if (numberExtraBits!=0){
			codedSegment.addBits(0,8-numberExtraBits);
			bitsCounter+=8-numberExtraBits;
		}
	}

	//////////////////////////////////
	//////////GET FUNCTIONS //////////
	//////////////////////////////////
	
	public int getCodingPasses(){
		return codingPasses;
	}
	
}
