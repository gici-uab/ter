/*
 * TER Software - More than an implementation of CCSDS Recommendation for Image Data Compression
 * Copyright (C) 2007  Group on Interactive Coding of Images (GICI)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Group on Interactive Coding of Images (GICI)
 * Department of Information and Communication Engineering
 * Autonomous University of Barcelona
 * 08193 - Bellaterra - Cerdanyola del Valles (Barcelona)
 * Spain
 *
 * http://gici.uab.es
 * http://sourceforge.net/projects/ter
 * gici-info@deic.uab.es
 */
package TER.TERcoder.SegmentCoder;

import GiciException.ParameterException;
import GiciStream.BitStream;
import GiciStream.ByteStream;



/**
 * This class entropy encodes the bitstream generated by the bit plane encoder
 * requires. Usage example:<br>
 * &nbsp; construct<br>
 * &nbsp; setParameters<br>
 * &nbsp; run<br>
 * 
 * @author Group on Interactive Coding of Images (GICI)
 * @version 1.1
 */
public class EncodeGaggleAC{

	
	/**
	 * This bitstream is used to store the sorting of a coded gaggle for a given bitplane after the entropy encoder.
	 * encodedGaggle[resolutionLevel]
	 */
	BitStream encodedGaggle[] = null;
	
	/**
	 * This bitstream contains the coded gaggle after the bit plane encoder, it also contains the contexts preceding the encoded words if necessary 
	 * sortingACGaggle[block][resolutionLevel][subband][codingPass]
	 */
	ByteStream sortingACGaggle[][][][] = null;

	
	/**
	 * This array indicated the type of entropy encoder.
	 * Valid values are:<br>
	 *   <ul>
	 *     <li>  0 - No entropy code for AC components  
	 *     <li>  1 - CCSDS Recommended  entropy coder 
	 *   </ul>
	 */
	int entropyAC;
	
	/**
	 * Definition in {@link SegmentCode2D#resolutionLevels}
	 */
	int resolutionLevels;

	/**
	 * To know if parameters are set.
	 * <p>
	 * True indicates that they are set otherwise false.
	 */
	boolean parametersSet = false;
	
	/**
	 * Indicates whether idSelection has been initialized.
	 */
	int ids[] = null;
	
	/**
	 * Definition in {@link CodeBlockAC#codeLength}
	 */
	int codeLength[] = null;
	
	/**
	 * Indicates for each length (2,3 or 4) the entropy code option that has been chosen.
	 */
	int idSelection[] = new int[3];
	
	/**
	 * Determines the ID for no code option for 2, 3 and 4 length symbols.
	 */
	int[] noCodeId = {1,3,3};
	
	/**
	 * Determines the number of bits required to encode the code option ID for 2, 3 and 4 length symbols.
	 */
	int[] codeIdLength = {1,2,2};
	
	/**
	 * Constructor of EncodeGaggleAC.
	 */
	public EncodeGaggleAC(){
		
	}
	
	/**
	 * Set the parameters used to entropy encode a gaggle.
	 * 
	 * @param sortingACGaggle definition in {@link #sortingACGaggle}
	 * @param entropyAC definition in {@link #entropyAC}
	 * @param codeLength definition in {@link CodeBlockAC#codeLength}
	 * @param resolutionLevels definition in {@link #resolutionLevels}
	 */
	public void setParameters(ByteStream sortingACGaggle[][][][],
			int entropyAC, int codeLength[], int resolutionLevels){
		
		this.sortingACGaggle = sortingACGaggle;

		this.entropyAC = entropyAC;

		this.resolutionLevels = resolutionLevels;
		
		this.codeLength = codeLength;
		
		parametersSet = true;
	}
	
	/**
	 * Performs entropy coding.
	 * 
	 * @return an array of bitstreams containing the entropy encoded image
	 *  
	 * @throws Exception when something goes wrong and entropy encoding must be stopped
	 */
	public BitStream[] run() throws Exception{
		//If parameters are not set run cannot be executed
		if(!parametersSet){
			throw new ParameterException("EntropyCoder cannot run if parameters are not set.");
		}
		
		if (entropyAC ==0){
			rawACEncoding();
		} else if (entropyAC==1){
			recommendedACEncoding();
		} else {
			System.out.println("\n Not implemented yet");
		}

		
		
		return encodedGaggle;
	}
	
	/**
	 * Entropy encode the bit stream generated by the bit plane encoder according to the specifications of the recommendation 
	 * for image data coding provided by the CCSDS.
	 * 
	 * @throws Exception when something goes wrong and entropy encoding must be stopped
	 */
	private void recommendedACEncoding() throws Exception{
		
		this.ids = new int[3];
		
		
		encodedGaggle = new BitStream[resolutionLevels];
		int blocksInGaggle = sortingACGaggle.length;
		int bufferAllocation = 4*blocksInGaggle;
		for(int k=0;k<resolutionLevels;k++){
			encodedGaggle[k] = new BitStream(bufferAllocation*8);
		}
		
		
		
		for(int k=0; k<3 ; k++){
			ids[k] = -1;
			setIdSelection();
		}	
		for (int rLevel=0 ; rLevel <= this.resolutionLevels  ; rLevel++){
			for (int block = 0 ; block< blocksInGaggle; block++ ){
				if (sortingACGaggle!=null){
					// here we encode the significance for each bitplane
					if (sortingACGaggle[block]!=null){	
						if (rLevel == 0 && sortingACGaggle[block][rLevel]!=null ){
							putResolutionLevel(block, rLevel);
						} else if (rLevel == 1 && this.resolutionLevels>1 ){
							putResolutionLevel(block, rLevel);
							putResolutionLevel(block, rLevel+1);
						} else if (rLevel > 2 ){
							putResolutionLevel(block, rLevel);
						}
						
					} //else {this bitPlane is empty for this block}
				}
			}
			
		}
		ids = null;
	}
	
	/**
	 * This function entropy encodes (according to CCSDS-IDC recommendation) the bit stream corresponding to the resolution level of a single block.
	 * 
	 * @param block indicates the number of the block inside the gaggle
	 * @param rLevel indicates the resolution level to be entropy encoded
	 * 
	 * @throws Exception when something goes wrong and entropy encoding must be stopped
	 */
	private void putResolutionLevel(int block, int rLevel) throws Exception{
		
		int codingACPasses = sortingACGaggle[block][rLevel][0].length;
		int numberOfSubbands = sortingACGaggle[block][rLevel].length;

		int rLevelAux = rLevel-1;
		if (rLevel <= 1){
			rLevelAux = rLevel;
		}
		int initialPass = 0;
		
		byte context = 0;
		
		if (rLevel>=2){
			int Di = 0;
			int DiLength = 0;
			//pass = 0 must be managed separately due the word to be mapped gives information of the three subbands
			
			for (int subband = 0 ; subband < numberOfSubbands ; subband++){
				if ( sortingACGaggle[block][rLevel][subband] != null){
					if ( sortingACGaggle[block][rLevel][subband][0] != null){
						int numBytes = sortingACGaggle[block][rLevel][subband][0].getNumBytes();
						if (numBytes>0){
							context  =	sortingACGaggle[block][rLevel][subband][0].getByte(0);
							//there is a bit to be encoded
							int bit = sortingACGaggle[block][rLevel][subband][0].getByte(1);
							DiLength++;
							Di = Di << 1;
							if (bit==1){
								Di++;
							}
						}
						
					}
				}
			}
			
			if (DiLength == 2){
				Di = mapIntoSymbol(Di,(byte) 65);
			} else if (DiLength == 3){
				if(rLevel == 2 ){
					Di = mapIntoSymbol(Di,(byte) 66);//in this case the context is 66
				} else {				
					Di = mapIntoSymbol(Di,(byte) 67);//in this case the context is 67
				}
			}
			
			putSymbol(Di,DiLength,rLevelAux);
			
			
			initialPass = 1;
		} 
		
		
		
		for ( int pass = initialPass ; pass < codingACPasses ; pass++ ){
			for (int subband = 0 ; subband < numberOfSubbands ; subband++){
				if ( sortingACGaggle[block][rLevel][subband] != null){
					if ( sortingACGaggle[block][rLevel][subband][pass] != null){
						int numBytes = sortingACGaggle[block][rLevel][subband][pass].getNumBytes();
						for(int k=0;k<numBytes;k+=2){
							context = sortingACGaggle[block][rLevel][subband][pass].getByte(k);
							int length = getLength(context);
							int word=sortingACGaggle[block][rLevel][subband][pass].getByte(k+1);

							int symbol =  mapIntoSymbol(word,context);
							putSymbol(symbol,length,rLevelAux);	
						}		
					}
				}
			}
		}
		
	}
	
	private int twoBitsVariablelengthCode_Option0[] = {1,1,1,0};
	private int lengthOfTwoBitsVariablelengthCode_Option0[] = {1,2,3,3};
	private int threeBitsVariablelengthCode_Option0[] = {1,1,1,0,1,2,6,7};
	private int lengthOfThreeBitsVariablelengthCode_Option0[] = {1,2,3,5,5,5,6,6};
	private int threeBitsVariablelengthCode_Option1[] = {2,3,2,3,2,3,0,1};
	private int lengthOfThreeBitsVariablelengthCode_Option1[] = {2,2,3,3,4,4,4,4};
	private int fourBitsVariablelengthCode_Option0[] = {1,1,1,1,0,1,2,3,8,9,10,11,12,13,14,15};
	private int lengthOfFourBitsVariablelengthCode_Option0[] = {1,2,3,4,7,7,7,7,8,8,8,8,8,8,8,8};
	private int fourBitsVariablelengthCode_Option1[] = {2,3,2,3,2,3,0,1,2,3,4,5,12,13,14,15};
	private int lengthOfFourBitsVariablelengthCode_Option1[] = {2,2,3,3,4,4,6,6,6,6,6,6,7,7,7,7};
	private int fourBitsVariablelengthCode_Option2[] = {4,5,6,7,4,5,6,7,4,5,6,7,0,1,2,3};
	private int lengthOfFourBitsVariablelengthCode_Option2[] = {3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5};
	
	/**
	 * This function adds a symbol to the resulting entropy encoded bit stream 
	 *  
	 * @param symbol indicates the symbol to be added
	 * @param length indicates the length of the symbol
	 * @param rLevel indicates the resolution level where the symbol belongs
	 */
	private void putSymbol(int symbol, int length, int rLevel){
		
		if(length>=2){	
			
			if(this.ids[length-2]==-1){
				int idLength = codeIdLength[length-2];
				ids[length-2] = idSelection[length-2];
				encodedGaggle[rLevel].addBits(ids[length-2],idLength);
			}

			if(ids[length-2]!=noCodeId[length-2]){
				if(length == 2){
					length = lengthOfTwoBitsVariablelengthCode_Option0[symbol];
					symbol = twoBitsVariablelengthCode_Option0[symbol];
				} else if(length == 3){
					if(ids[length-2]==0){
						length = lengthOfThreeBitsVariablelengthCode_Option0[symbol];
						symbol = threeBitsVariablelengthCode_Option0[symbol];
					} else if (ids[length-2]==1){
						length = lengthOfThreeBitsVariablelengthCode_Option1[symbol];
						symbol = threeBitsVariablelengthCode_Option1[symbol];
					}	
				} else if (length == 4){
					if(ids[length-2]==0){
						length = lengthOfFourBitsVariablelengthCode_Option0[symbol];
						symbol = fourBitsVariablelengthCode_Option0[symbol];
					} else if (ids[length-2]==1){
						length = lengthOfFourBitsVariablelengthCode_Option1[symbol];
						symbol = fourBitsVariablelengthCode_Option1[symbol];
					} else if (ids[length-2]==2){
						length = lengthOfFourBitsVariablelengthCode_Option2[symbol];
						symbol = fourBitsVariablelengthCode_Option2[symbol];
					}
				}
			}
		} else if (length<0){
				length = -length;
		}
		
		
		encodedGaggle[rLevel].addBits(symbol,length);
	}
	
	
	/**
	 * Sets the code option for the 2, 3 and 4 length symbols. The selection is based in the data contained in {@link CodeBlockAC#codeLength}.
	 */
	private void setIdSelection(){
		if(this.codeLength!=null){
			//First we select the option for two length symbols
			if(this.codeLength[0]<this.codeLength[1]){
				this.idSelection[0]=0;
			} else {
				this.idSelection[0]=1;
			}
			//Then we select the option for three length symbols
			int min = this.codeLength[4];
			int codeId=3;
			for(int k=2; k<4; k++){
				if (this.codeLength[k]<min){
					min=this.codeLength[k];
					codeId=k-2;
				}
			}
			this.idSelection[1]=codeId;
			//Finally we select the option for four length symbols
			min = this.codeLength[8];
			codeId=3;
			for(int k=5; k<8; k++){
				if (this.codeLength[k]<min){
					min=this.codeLength[k];
					codeId=k-5;
				}
			}
			this.idSelection[2]=codeId;
		} else {// in this case NoCode option is selected
			this.idSelection[0]=1;
			this.idSelection[1]=3;
			this.idSelection[2]=3;
		}
	}

	/**
	 * Determines the symbol that corresponds to the word and the context given
	 * 
	 * @param word contains a word that has been encoded
	 * @param context indicates the kind of word to be encoded, i.e. the lenght and the encoding pass
	 * 
	 * @return the symbol that correspond to the given word with the given context
	 */
	private int mapIntoSymbol(int word, byte context){
		int symbol = 0;
		int PDF2MapperGeneral[] = {0,2,1,3};
		int PDF3MapperGeneral[] = {1,4,0,5,2,6,3,7};
		int PDF3MapperImpossibleValue[] = {/*-1*/7,3,0,4,1,5,2,6}; // 000 is impossible
		int PDF4MapperGeneral[] = {10,1,3,6,2,5,9,12,0,8,7,13,4,14,11,15};
		int PDF4MapperImpossibleValue[] = {/*-1*/15,1,3,6,2,5,9,11,0,8,7,12,4,13,10,14}; // 0000 is impossible (if 3 levels are applied)
		
		switch(context){
		case (byte) 64: // 1-bit significance word
			symbol=word;
		break;
		case (byte) 65: // 2-bit significance word
			symbol=PDF2MapperGeneral[word];
		break;
		case (byte) 66: // 3-bit significance word, 000 impossible value
			symbol=PDF3MapperImpossibleValue[word];	
		break;		
		case (byte) 67: // 3-bit significance word, general case (any value is possible)
			symbol=PDF3MapperGeneral[word];	
		break;
		case (byte) 68: // 4-bit significance word, 0000 impossible value
			symbol=PDF4MapperImpossibleValue[word];	
		break;		
		case (byte) 69: // 4-bit significance word, general case (any value is possible)
			symbol=PDF4MapperGeneral[word];	
		break;	
		default :
			symbol=word;
		}
		return symbol;
	}
	
	/**
	 * Determines the lenght of a word from its context.
	 * 
	 * @param context indicates the kind of word to be encoded, i.e. the lenght and the encoding pass
	 * 
	 * @return the length of the encoded word, for sign word the length is expressed with a negative number
	 */
	private int getLength(byte context){
		int length = 0;
		switch(context){
		case (byte) 64: // 1-bit significance word
			length=1;
		break;
		case (byte) 65: // 2-bit significance word
			length=2;
		break;
		case (byte) 66: // 3-bit significance word, 000 impossible value
			length=3;	
		break;		
		case (byte) 67: // 3-bit significance word, general case (any value is possible)
			length=3;	
		break;
		case (byte) 68: // 4-bit significance word, 000 impossible value
			length=4;
		break;		
		case (byte) 69: // 4-bit significance word, general case (any value is possible)
			length=4;
		break;	
		case (byte) 70: // 1-bit sign word
			length=-1;
		break;
		case (byte) 71: // 2-bit sign word
			length=-2;
		break;
		case (byte) 72: // 3-bit sign word
			length=-3;	
		break;		
		case (byte) 73: // 4-bit sign word
			length=-4;	
		break;
		default :
			length=1;
		
		}
		return length;
	}
	

	/**
	 * Raw encode the bit stream generated by the bit plane encoder 
	 * 
	 * @throws Exception when something goes wrong and entropy encoding must be stopped
	 */
	private void rawACEncoding() throws Exception{
		
		encodedGaggle = new BitStream[resolutionLevels];
		int blocksInGaggle = sortingACGaggle.length;
		int bufferAllocation = 4*blocksInGaggle;
		for(int k=0;k<resolutionLevels;k++){
			encodedGaggle[k] = new BitStream(bufferAllocation*8);
		}
		
		
		
			
		for (int rLevel=0 ; rLevel <= this.resolutionLevels  ; rLevel++){
			for (int block = 0 ; block< blocksInGaggle; block++ ){
				if (sortingACGaggle!=null){
					// here we encode the significance for each bitplane
					if (sortingACGaggle[block]!=null){	
						if (rLevel == 0 && sortingACGaggle[block][rLevel]!=null ){
							putResolutionLevelRaw(block, rLevel);
						} else if (rLevel == 1 && this.resolutionLevels>1 ){
							putResolutionLevelRaw(block, rLevel);
							putResolutionLevelRaw(block, rLevel+1);
						} else if (rLevel > 2 ){
							putResolutionLevelRaw(block, rLevel);
						}
						
					} //else {this bitPlane is empty for this block}
				}
			}
			
		};
	}

	/**
	 * This function raw encodes the bit stream corresponding to the resolution level of a single block.
	 * 
	 * @param block indicates the number of the block inside the gaggle
	 * @param rLevel indicates the resolution level to be entropy encoded
	 * 
	 * @throws Exception when something goes wrong and entropy encoding must be stopped
	 */
	private void putResolutionLevelRaw(int block, int rLevel) throws Exception{
		
		int codingACPasses = sortingACGaggle[block][rLevel][0].length;
		int numberOfSubbands = sortingACGaggle[block][rLevel].length;
		
		int rLevelAux = rLevel-1;
		if (rLevel <= 1){
			rLevelAux = rLevel;
		}
		
		for ( int pass = 0 ; pass < codingACPasses ; pass++ ){
			for (int subband = 0 ; subband < numberOfSubbands ; subband++){
				if ( sortingACGaggle[block][rLevel][subband] != null){
					if ( sortingACGaggle[block][rLevel][subband][pass] != null){
						int numBytes = sortingACGaggle[block][rLevel][subband][pass].getNumBytes();
						for(int k=0;k<numBytes;k+=2){
							
							int length = sortingACGaggle[block][rLevel][subband][pass].getByte(k);
							int word=sortingACGaggle[block][rLevel][subband][pass].getByte(k+1);
							
							encodedGaggle[rLevelAux].addBits(word,length);
							
						}		
					}
				}
			}
		}
		
		
	}
}	
